# sstable-to-arrow

This folder contains the source code for sstable-to-arrow. It uses CMake as a build tool generator and is divided into several sub-projects:

- `exe/` contains the code for the executable.
- `src/` contains the code for the sstable-to-arrow library.
- `parser/` contains the code that reads SSTable files and exposes the data as Kaitai Struct objects.
    - `src/ksy/` contains the Kaitai Struct declarations for the various SSTable classes.
    - `src/opaque/` contains different "opaque types" (types defined outside of Kaitai) as well as classes to help parse and transform the data. If you would like to parse SSTables in a different language supported by Kaitai, you will need to rewrite these files in that language.
- `python/` contains an under-development library that exposes Python bindings to access the C++ library. This is not included in the Docker container and should be built separately.

Be warned that error handling and logging are extremely rudimentary, as this is an alpha release.

## How to run

This project can be run through a [Docker](https://www.docker.com/) container via
```bash
docker run --rm -it datastaxlabs/sstable-to-arrow
```

To read SSTables on your filesystem, you will need to mount them using docker:
```bash
# replace /path/to/sstable/directory with the path to the directory with your sstables
docker run --rm -itp 9143:9143 -v /path/to/sstable/directory:/mnt/sstables --name sstable-to-arrow datastaxlabs/sstable-to-arrow /mnt/sstables
```

With the VS Code [Remote - Containers](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers) extension installed, you can also open this folder in VS Code, run `Open Folder in Container` from the command palette, and select this folder to run the project within a Docker container.

If not using Docker, you can manually build the project as follows, though installation of dependencies may vary from machine to machine. You can see the [Dockerfile](Dockerfile) for example commands on a Linux machine.

1. This project depends on [Kaitai Struct](`https://kaitai.io/#download`), the [Kaitai Struct C++/STL runtime library](https://github.com/kaitai-io/kaitai_struct_cpp_stl_runtime), and [Apache Arrow for C++](http://arrow.apache.org/docs/cpp/cmake.html). If you are manually building Arrow and using other Arrow features like the filesystem interface `arrow::fs`, make sure to check [if you need to include any optional components](http://arrow.apache.org/docs/developers/cpp/building.html#optional-components). **This project requires `-DARROW_PARQUET=ON`.** See the `RUN` commands in the [`Dockerfile`](Dockerfile) for an example.

2. Get (an) SSTable(s). You can download IOT (Internet of Things) sample data generated by [NoSQLBench](http://docs.nosqlbench.io/#/) [at this Google Drive folder](https://drive.google.com/drive/folders/1y-f6rRH3OfC8AvVTNuhcmvjihnaMWN4p?usp=sharing). You can also generate IOT data using the script at [../test/generate-data](../test/generate-data), or you can manually create a table using CQL and the Cassandra Docker image using the steps below. See [the Cassandra quickstart](https://cassandra.apache.org/quickstart/) for more info.

3. Compile as follows:

```bash
mkdir build
cd build
cmake .. # or if using ninja: cmake -GNinja ..
make # or: ninja
```

4. Run:

```bash
./exe/sstable-to-arrow <PATH_TO_SSTABLE_DIRECTORY>
```

This will listen for a connection on port 9143. It expects the client to send a
message first, and then it will send data in the following format:

1. The number of Arrow Tables being transferred, an 8-byte big-endian unsigned integer
2. For each table:
    1. Its size in bytes as an 8-byte big-endian unsigned integer
    2. The contents of the table in Arrow IPC Stream Format

## Additional features

sstable-to-arrow can also save the SSTable data as a Parquet file by passing the `-p` flag along with the destination file path. Read the full usage details by running `./exe/sstable-to-arrow -h`.

An `sstable_to_pyarrow` Python library is also currently under development. The underlying C++ library is located in `cpp/python` and uses [Boost.Python](https://www.boost.org/doc/libs/1_77_0/libs/python/doc/html/index.html) to provide Python bindings.

## Limitations and caveats

- sstable-to-arrow does not do deduping and sends each SSTable as an Arrow Table. The user must configure a cuDF per sstable and use the GPU to merge the sstables based on last write wins semantics. sstable-to-arrow exposes internal cassandra timestamps so that merging can be done at the cuDF layer. Support for tombstones is currently under development.
- Some information, namely the names of the partition key and clustering columns, can't actually be deduced from the SSTable files, so they are represented in the table as simply `partition key` and `clustering key`.
- Cassandra stores data in memtables and commitlog before flushing to sstables, so analytics performed via only sstable-to-arrow will potentially be stale / not real-time.
- Currently, the parser has only been tested with SSTables written by Cassandra OSS 3.11. These *should* be identical to SSTables written by Cassandra 3.x.
- The system is set up to scan entire sstables (not read specific partitions). More work will be needed if we ever do predicate pushdown.
- Limitations with types:
- The following cql types are not supported: `counter`, `frozen`, and user-defined types.
- `varint`s can only store up to 8 bytes. Attempting to read a table with larger `varint`s will crash.
- The parser can only read tables with up to 64 columns.
- `decimal`s are converted into an 8-byte floating point value because neither C++ nor Arrow has native support for arbitrary-precision integers or decimals like of the Java `BigInteger` or `BigDecimal` classes. This means that operations on decimal columns will use floating point arithmetic, which may be inexact.
- `set`s are treated as lists since Arrow has no equivalent of a set.
- cuDF only implements a subset of Apache Arrow, so some types in Arrow are not yet supported in cuDF. By passing the `-g` flag, you can pass the raw bytes for most of these data types as a hexadecimal string instead.
- UUIDs in collections are not supported.

## TODO

- Fix or improve limitations above
    - Add support for row tombstone markers
- Improve error handling system and logging system
- Improve documentation and user friendliness with the CLI
- Improve Python bindings
- Refactor to allow conversion of larger-than-memory SSTables
